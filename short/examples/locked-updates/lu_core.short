// Single key model

protocol lu {
  roles Client, Server
  constant NIL, init_Server

  interaction core {
    msg Client -> Set<Server> prepare     (BOOLEAN val) // prepare
    msg Server ->     Client  prepareAck  ()

    msg Client -> Set<Server> commit      ()            // the prepared val
    msg Server ->     Client  commitAck   ()            // the prepared val

    msg Client -> Set<Server> rd          ()
    msg Server ->     Client  rdRes       (BOOLEAN val)

    role Client {
      state view Set<Server> = init_Server
      state BOOLEAN done

      // An example client access sequence. A wr followed by read.
      handle event wrrd(BOOLEAN v) {
        // ---- prepare
        view(Server) !! prepare(val=v)
        await msg prepareAck from all(Server)
        // ---- commit
        view(Server) !! commit()
        await msg commitAck from all(Server)
        // ---- read
        view(Server) !! rd()
        await msg rdRes from all(Server)

        change done = TRUE
      }
    }

    role Server {
      state NIL<BOOLEAN> cvalue = NIL // NIL only initially when never commited
      state NIL<BOOLEAN> pvalue = NIL // NIL means no prepare pending

      // Prepare does not fail. We buffer prepare messages if already prepared 
      // Assumes in-order message delivery and requires selective receive.
      when (pvalue = NIL) handle msg prepare { 
        change pvalue = prepare.val
        reply prepareAck()
      }

      using selective_receive
      handle msg commit {
        assert(pvalue # NIL, "Commit is missing previous prepare.")
        change cvalue = pvalue, pvalue = NIL
        reply commitAck()
      }

      handle msg rd { 
        reply rdRes(val=cvalue) // always show committed value
      }
    }
  }

  // List of invariants
  interaction check_these {
    // All committed servers have the same value
    tla { Consistency ==
            \A a,b \in Server: 
              IF    st_Server[a].pvalue = NIL (* both committed *)
                 /\ st_Server[b].pvalue = NIL 
                THEN st_Server[a].cvalue = st_Server[b].cvalue
                ELSE TRUE
    }

    // Instead of the "Life is good" assertion in the client, let's find a 
    // state where both clients have completed their run. We need to negate
    // the condition to violate the invariant in the stample state we seek.
    // I.e. keep searching while there are client left that are not done.
    // Run TLC a few times to see different interleavings of clients.
    tla { Trap == 
            \E c \in Client: ~st_Client[c].done
    }
  }
}

// short lu_core.short >lu.tla && tlc lu.tla 2>t && ./show t